<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NBA MVP Predictions — ML Model</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>NBA <span>MVP</span> Predictions</h1>
    <p class="subtitle">Machine learning model tested on 46 seasons of historical data</p>
    <div class="summary-stats" id="summary-stats"></div>
  </header>

  <div class="container">
    <p class="model-description">Predictions from an XGBoost model trained on 51 features — player stats, team record, and historical MVP patterns. Each year is predicted using a model trained on all other seasons, so no future data leaks into predictions.</p>

    <div class="tabs">
      <button class="tab-btn active" data-tab="years">Year-by-Year Results</button>
      <button class="tab-btn" data-tab="scatter">MVP Scatter Plot</button>
      <button class="tab-btn" data-tab="deserving">Most / Least Deserving</button>
      <button class="tab-btn" data-tab="alltime">All-Time Great Seasons</button>
    </div>

    <!-- Tab 1: Year-by-Year -->
    <div id="tab-years" class="tab-content">
      <div class="filter-bar">
        <label for="year-from">From:</label>
        <select id="year-from"></select>
        <label for="year-to">To:</label>
        <select id="year-to"></select>
        <label for="match-filter">Show:</label>
        <select id="match-filter">
          <option value="all">All</option>
          <option value="correct">Correct only</option>
          <option value="top3">Top-3 hits</option>
          <option value="miss">Misses only</option>
        </select>
      </div>
      <table id="years-table">
        <thead>
          <tr>
            <th>Year</th>
            <th>Actual MVP</th>
            <th>Predicted #1</th>
            <th>Match</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Tab 2: Scatter Plot -->
    <div id="tab-scatter" class="tab-content" style="display:none">
      <p class="tab-description">Every MVP candidate plotted by how the model values two dimensions of their season. Both axes are derived from SHAP values — the model's own explanation of each prediction, split into features that measure <strong>Team Context &amp; Winning</strong> (x-axis: win%, seed, win shares, prior MVPs) versus <strong>Individual Performance</strong> (y-axis: scoring, rebounds, assists, efficiency, BPM). Axes are percentile-ranked across all ~6,000 candidates. Dot size reflects predicted vote share.</p>
      <div class="filter-bar">
        <label for="scatter-year-from">From:</label>
        <select id="scatter-year-from"></select>
        <label for="scatter-year-to">To:</label>
        <select id="scatter-year-to"></select>
        <label for="scatter-topn">Per year:</label>
        <select id="scatter-topn">
          <option value="5" selected>Top 5</option>
          <option value="10">Top 10</option>
        </select>
        <label class="toggle-label"><input type="checkbox" id="scatter-mvps-only"> MVPs only</label>
        <label for="scatter-player">Player:</label>
        <input type="text" id="scatter-player" placeholder="e.g. LeBron" list="scatter-player-list" autocomplete="off">
        <datalist id="scatter-player-list"></datalist>
      </div>
      <div class="scatter-wrap">
        <canvas id="scatter-canvas" width="800" height="600"></canvas>
        <div id="scatter-tooltip" class="scatter-tooltip"></div>
      </div>
    </div>

    <!-- Tab 3: Deserving -->
    <div id="tab-deserving" class="tab-content" style="display:none">
      <div class="deserving-section">
        <h3>Biggest Snubs &amp; Deserving Non-Winners</h3>
        <p class="tab-description">A <strong>snub</strong> is when the model predicted a player to win over the actual winner — i.e. the model thinks they were robbed. <strong>Deserving</strong> means a great season, but the actual winner's stats were even stronger. Example: Jokić 2025 was incredible, but SGA's season was one of the best in the dataset — not a snub, just outshone.</p>
        <table id="snubs-table">
          <thead>
            <tr>
              <th class="sortable" data-col="player">Player</th>
              <th class="sortable" data-col="year">Year</th>
              <th class="sortable" data-col="team">Team</th>
              <th class="sortable" data-col="predicted_share">Predicted Share</th>
              <th class="sortable" data-col="actual_share">Actual Share</th>
              <th>Who Won</th>
              <th>Verdict</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="deserving-section">
        <h3>Least Statistically Deserving Winners — Lowest Predicted Share</h3>
        <table id="least-table">
          <thead>
            <tr>
              <th class="sortable" data-col="player">Player</th>
              <th class="sortable" data-col="year">Year</th>
              <th class="sortable" data-col="team">Team</th>
              <th class="sortable" data-col="predicted_share">Predicted Share</th>
              <th class="sortable" data-col="actual_share">Actual Share</th>
              <th>Model Predicted</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- Tab 4: All-Time Great Seasons -->
    <div id="tab-alltime" class="tab-content" style="display:none">
      <p class="tab-description">Player-seasons ranked by predicted vote share across all years. A high predicted share means the model sees that season as an all-time great MVP case regardless of who else was playing that year.</p>
      <div class="filter-bar">
        <label for="alltime-count">Show top:</label>
        <select id="alltime-count">
          <option value="25">25</option>
          <option value="50" selected>50</option>
          <option value="100">100</option>
          <option value="200">200</option>
        </select>
        <label for="alltime-winner-filter">Filter:</label>
        <select id="alltime-winner-filter">
          <option value="all">All players</option>
          <option value="winners">Winners only</option>
          <option value="nonwinners">Non-winners only</option>
        </select>
      </div>
      <table id="alltime-table">
        <thead>
          <tr>
            <th>Rank</th>
            <th class="sortable" data-col="player">Player</th>
            <th class="sortable" data-col="year">Year</th>
            <th class="sortable" data-col="team">Team</th>
            <th class="sortable" data-col="predicted_share">Predicted Share</th>
            <th class="sortable" data-col="actual_share">Actual Share</th>
            <th>Won MVP?</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <footer>
    <p>Built with XGBoost + leave-one-year-out cross-validation &middot;
      <a href="https://github.com/mpg000f/nba-mvp">Source on GitHub</a></p>
  </footer>

<script>
let DATA = null;

async function init() {
  const resp = await fetch("data.json");
  DATA = await resp.json();
  renderSummary();
  populateFilters();
  renderYears();
  renderDeserving();
  renderAllTime();
  setupTabs();
  setupSort();
  setupScatter();
}

function renderSummary() {
  const s = DATA.summary;
  const pct = ((s.top1 / s.n) * 100).toFixed(1);
  document.getElementById("summary-stats").innerHTML = `
    <div class="stat-box"><div class="num">${s.top1}/${s.n}</div><div class="label">Top-1 Correct (${pct}%)</div></div>
    <div class="stat-box"><div class="num">${s.top3}/${s.n}</div><div class="label">Top-3 Correct</div></div>
    <div class="stat-box"><div class="num">${s.top5}/${s.n}</div><div class="label">Top-5 Correct</div></div>
  `;
}

function populateFilters() {
  const years = DATA.years.map(y => y.year);
  const fromSel = document.getElementById("year-from");
  const toSel = document.getElementById("year-to");
  years.forEach(y => {
    fromSel.add(new Option(y, y));
    toSel.add(new Option(y, y));
  });
  fromSel.value = years[0];
  toSel.value = years[years.length - 1];
  fromSel.addEventListener("change", renderYears);
  toSel.addEventListener("change", renderYears);
  document.getElementById("match-filter").addEventListener("change", renderYears);
  document.getElementById("alltime-count").addEventListener("change", renderAllTime);
  document.getElementById("alltime-winner-filter").addEventListener("change", renderAllTime);

  // Scatter filters
  const sfrom = document.getElementById("scatter-year-from");
  const sto = document.getElementById("scatter-year-to");
  years.forEach(y => {
    sfrom.add(new Option(y, y));
    sto.add(new Option(y, y));
  });
  sfrom.value = years[0];
  sto.value = years[years.length - 1];
  sfrom.addEventListener("change", drawScatter);
  sto.addEventListener("change", drawScatter);
  document.getElementById("scatter-topn").addEventListener("change", drawScatter);
  document.getElementById("scatter-mvps-only").addEventListener("change", drawScatter);

  // Player search with datalist autocomplete
  const playerInput = document.getElementById("scatter-player");
  const playerList = document.getElementById("scatter-player-list");
  const uniqueNames = [...new Set(DATA.deserving.map(d => d.player))].sort();
  uniqueNames.forEach(name => {
    playerList.appendChild(new Option(name));
  });
  playerInput.addEventListener("input", drawScatter);
}

function matchIcon(m) {
  if (m === "correct") return '<span class="match-icon match-correct">\u2713</span>';
  if (m === "top3") return '<span class="match-icon match-top3">~</span>';
  return '<span class="match-icon match-miss">\u2717</span>';
}

function statLine(p) {
  const fg = p.fg_pct != null ? (p.fg_pct * 100).toFixed(1) : "—";
  const tp = p.three_pct != null ? (p.three_pct * 100).toFixed(1) : "—";
  const bpm = p.bpm != null ? p.bpm.toFixed(1) : "—";
  const ws = p.ws != null ? p.ws.toFixed(1) : "—";
  const wins = p.team_wins != null ? Math.round(p.team_wins) : "?";
  const seed = p.conf_seed != null ? Math.round(p.conf_seed) : "?";
  return `<span class="stat-line">${p.pts.toFixed(1)} PTS, ${(p.trb||0).toFixed(1)} TRB, ${(p.ast||0).toFixed(1)} AST | ${fg}% FG, ${tp}% 3P | ${bpm} BPM, ${ws} WS | ${wins}W, #${seed}</span>`;
}

function renderYears() {
  const from = +document.getElementById("year-from").value;
  const to = +document.getElementById("year-to").value;
  const mf = document.getElementById("match-filter").value;
  const tbody = document.querySelector("#years-table tbody");
  tbody.innerHTML = "";

  DATA.years.filter(y => y.year >= from && y.year <= to).forEach(y => {
    if (mf !== "all" && y.match !== mf) return;

    const tr = document.createElement("tr");
    tr.className = `row-${y.match} clickable`;
    tr.innerHTML = `
      <td>${y.year}</td>
      <td>${y.actual_mvp}</td>
      <td>${y.predicted_mvp}</td>
      <td>${matchIcon(y.match)}</td>
    `;
    tr.addEventListener("click", () => toggleDetail(tr, y));
    tbody.appendChild(tr);
  });
}

function pctBar(normShare) {
  const pct = Math.round(normShare * 100);
  return `<span class="pct-bar"><span class="pct-fill" style="width:${pct}%"></span></span>`;
}

function toggleDetail(tr, y) {
  const next = tr.nextElementSibling;
  if (next && next.classList.contains("detail-row")) {
    next.remove();
    return;
  }
  document.querySelectorAll(".detail-row").forEach(r => r.remove());

  const detail = document.createElement("tr");
  detail.className = "detail-row";
  const td = document.createElement("td");
  td.colSpan = 4;

  const makeList = (items, shareCol, showNorm) =>
    items.map(p => {
      const stats = statLine(p);
      const ns = showNorm && p.norm_share ? ` — ${(p.norm_share * 100).toFixed(1)}%` : "";
      const bar = showNorm && p.norm_share ? pctBar(p.norm_share) : "";
      return `<li>
        <div class="detail-player">${p.player} <span class="team">${p.team}</span> <span class="share">(${p.share.toFixed(3)}${ns})</span>${bar}</div>
        <div class="detail-stats">${stats}</div>
      </li>`;
    }).join("");

  td.innerHTML = `
    <div class="detail-content">
      <div class="detail-panel">
        <h4>Actual Top 5 (by vote share)</h4>
        <ol>${makeList(y.actual_top5, "share", false)}</ol>
      </div>
      <div class="detail-panel">
        <h4>Predicted Top 5 (within-year share)</h4>
        <ol>${makeList(y.predicted_top5, "share", true)}</ol>
      </div>
    </div>
  `;
  detail.appendChild(td);
  tr.after(detail);
}

function renderDeserving() {
  const d = DATA.deserving;

  const snubs = d.filter(p => !p.was_mvp)
    .sort((a, b) => b.predicted_share - a.predicted_share)
    .slice(0, 50);

  const snubsTbody = document.querySelector("#snubs-table tbody");
  snubs.forEach(p => {
    const isSnub = p.snub_type === "snub";
    const tr = document.createElement("tr");
    if (isSnub) tr.className = "row-snub";
    tr.innerHTML = `
      <td>${p.player}</td>
      <td>${p.year}</td>
      <td>${p.team}</td>
      <td>${p.predicted_share.toFixed(4)}</td>
      <td>${p.actual_share.toFixed(4)}</td>
      <td>${p.actual_mvp}</td>
      <td><span class="verdict-badge ${isSnub ? 'verdict-snub' : 'verdict-deserving'}">${isSnub ? 'Snub' : 'Deserving'}</span></td>
    `;
    snubsTbody.appendChild(tr);
  });

  const winners = d.filter(p => p.was_mvp)
    .sort((a, b) => a.predicted_share - b.predicted_share);

  const yearPredMap = {};
  DATA.years.forEach(y => { yearPredMap[y.year] = y.predicted_mvp; });

  const leastTbody = document.querySelector("#least-table tbody");
  winners.forEach(p => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${p.player}</td>
      <td>${p.year}</td>
      <td>${p.team}</td>
      <td>${p.predicted_share.toFixed(4)}</td>
      <td>${p.actual_share.toFixed(4)}</td>
      <td>${yearPredMap[p.year] || "-"}</td>
    `;
    leastTbody.appendChild(tr);
  });
}

function renderAllTime() {
  const count = +document.getElementById("alltime-count").value;
  const filter = document.getElementById("alltime-winner-filter").value;
  const tbody = document.querySelector("#alltime-table tbody");
  tbody.innerHTML = "";

  let pool = DATA.deserving.slice();
  if (filter === "winners") pool = pool.filter(p => p.was_mvp);
  else if (filter === "nonwinners") pool = pool.filter(p => !p.was_mvp);

  pool.sort((a, b) => b.predicted_share - a.predicted_share);
  pool.slice(0, count).forEach((p, i) => {
    const tr = document.createElement("tr");
    if (p.was_mvp) tr.className = "row-alltime-winner";
    tr.innerHTML = `
      <td>${i + 1}</td>
      <td>${p.player}</td>
      <td>${p.year}</td>
      <td>${p.team}</td>
      <td>${p.predicted_share.toFixed(4)}</td>
      <td>${p.actual_share.toFixed(4)}</td>
      <td>${p.was_mvp ? '<span class="match-icon match-correct">\u2713</span>' : ""}</td>
    `;
    tbody.appendChild(tr);
  });
}

function setupTabs() {
  document.querySelectorAll(".tab-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      document.querySelectorAll(".tab-content").forEach(c => c.style.display = "none");
      document.getElementById("tab-" + btn.dataset.tab).style.display = "block";
      if (btn.dataset.tab === "scatter") drawScatter();
    });
  });
}

function setupSort() {
  document.querySelectorAll("th.sortable").forEach(th => {
    th.addEventListener("click", () => {
      const table = th.closest("table");
      const tbody = table.querySelector("tbody");
      const col = th.dataset.col;
      const isNum = ["year", "predicted_share", "actual_share", "pts"].includes(col);

      const wasAsc = th.classList.contains("sort-asc");
      table.querySelectorAll("th").forEach(h => { h.classList.remove("sort-asc", "sort-desc"); });
      const dir = wasAsc ? "desc" : "asc";
      th.classList.add("sort-" + dir);

      const rows = Array.from(tbody.querySelectorAll("tr"));
      const colIdx = Array.from(th.parentElement.children).indexOf(th);
      rows.sort((a, b) => {
        let va = a.children[colIdx].textContent.trim();
        let vb = b.children[colIdx].textContent.trim();
        if (isNum) { va = parseFloat(va); vb = parseFloat(vb); }
        if (va < vb) return dir === "asc" ? -1 : 1;
        if (va > vb) return dir === "asc" ? 1 : -1;
        return 0;
      });
      rows.forEach(r => tbody.appendChild(r));
    });
  });
}

/* ===== Scatter Plot ===== */

let scatterDots = [];  // cached for hover lookup
const headshotCache = {};  // code -> Image (loaded or loading)
const HEADSHOT_BASE = "https://www.basketball-reference.com/req/202106291/images/headshots/";

function getHeadshot(code) {
  if (!code) return null;
  if (headshotCache[code]) return headshotCache[code];
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = HEADSHOT_BASE + code + ".jpg";
  img.onload = () => { img._loaded = true; drawScatter(); };
  img.onerror = () => { img._failed = true; };
  headshotCache[code] = img;
  return img;
}

function setupScatter() {
  const canvas = document.getElementById("scatter-canvas");
  const tooltip = document.getElementById("scatter-tooltip");

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // Convert mouse position to logical canvas coordinates (before DPR scaling)
    const sx = mx / rect.width * 800;
    const sy = my / rect.height * 600;

    // Find the top-most (last-drawn) dot under the cursor.
    // scatterDots is in draw order: non-MVPs first, MVPs on top.
    let hit = null;
    for (let i = scatterDots.length - 1; i >= 0; i--) {
      const dot = scatterDots[i];
      const dx = dot.cx - sx, dy = dot.cy - sy;
      if (dx * dx + dy * dy < dot.r * dot.r + 100) {
        hit = dot;
        break;
      }
    }

    if (hit) {
      const d = hit.data;
      const fg = d.fg_pct != null ? (d.fg_pct * 100).toFixed(1) : "—";
      let shapHtml = "";
      if (d.shap_top && d.shap_top.length > 0) {
        const lines = d.shap_top.map(([feat, val]) => {
          const sign = val >= 0 ? "+" : "";
          const cls = val >= 0 ? "shap-pos" : "shap-neg";
          return `<span class="${cls}">${sign}${val.toFixed(3)}</span> ${feat}`;
        });
        shapHtml = `<div class="shap-breakdown"><div class="shap-label">Model drivers:</div>${lines.join("<br>")}</div>`;
      }
      tooltip.innerHTML = `<strong>${d.player}</strong> (${d.year}, ${d.team})` +
        (d.was_mvp ? " <strong>★ MVP</strong>" : "") +
        `<br>${d.pts.toFixed(1)} PTS, ${(d.trb||0).toFixed(1)} TRB, ${(d.ast||0).toFixed(1)} AST` +
        `<br>${fg}% FG | ${(d.bpm||0).toFixed(1)} BPM, ${(d.ws||0).toFixed(1)} WS` +
        `<br>Pred share: ${d.predicted_share.toFixed(3)}` +
        shapHtml;
      tooltip.style.display = "block";
      tooltip.style.left = (e.clientX - rect.left + 14) + "px";
      tooltip.style.top = (e.clientY - rect.top - 10) + "px";

      // Keep tooltip within canvas area
      const tw = tooltip.offsetWidth;
      if (e.clientX - rect.left + 14 + tw > rect.width) {
        tooltip.style.left = (e.clientX - rect.left - tw - 10) + "px";
      }
    } else {
      tooltip.style.display = "none";
    }
  });

  canvas.addEventListener("mouseleave", () => {
    tooltip.style.display = "none";
  });
}

function rescalePercentiles(pool) {
  // Compute percentile ranks within this filtered group from raw SHAP sums
  const teamVals = pool.map(d => d.shap_team).slice().sort((a, b) => a - b);
  const indivVals = pool.map(d => d.shap_indiv).slice().sort((a, b) => a - b);

  function pctRank(sorted, val) {
    // Count values strictly less than val
    let lo = 0, hi = sorted.length;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      if (sorted[mid] < val) lo = mid + 1;
      else hi = mid;
    }
    return sorted.length > 1 ? (lo / (sorted.length - 1)) * 100 : 50;
  }

  return pool.map(d => ({
    ...d,
    _wx: pctRank(teamVals, d.shap_team),
    _iy: pctRank(indivVals, d.shap_indiv),
  }));
}

function drawScatter() {
  const canvas = document.getElementById("scatter-canvas");
  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  const W = 800, H = 600;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + "px";
  canvas.style.height = H + "px";
  ctx.scale(dpr, dpr);

  const from = +document.getElementById("scatter-year-from").value;
  const to = +document.getElementById("scatter-year-to").value;
  const topN = +document.getElementById("scatter-topn").value;
  const mvpOnly = document.getElementById("scatter-mvps-only").checked;

  // Filter data — year range first
  let pool = DATA.deserving.filter(d =>
    d.year >= from && d.year <= to &&
    d.shap_team != null && d.shap_indiv != null
  );

  // Keep only top N by predicted_share per year
  if (topN > 0) {
    const byYear = {};
    pool.forEach(d => { (byYear[d.year] = byYear[d.year] || []).push(d); });
    pool = [];
    for (const yr in byYear) {
      byYear[yr].sort((a, b) => b.predicted_share - a.predicted_share);
      pool.push(...byYear[yr].slice(0, topN));
    }
  }

  if (mvpOnly) pool = pool.filter(d => d.was_mvp);

  // Rescale percentiles on the full candidate pool (before player filter)
  pool = rescalePercentiles(pool);

  // Player name filter — applied after rescaling so positions stay relative to full pool
  const playerQuery = document.getElementById("scatter-player").value.trim().toLowerCase();
  if (playerQuery) {
    pool = pool.filter(d => d.player.toLowerCase().includes(playerQuery));
  }

  // Margins
  const ml = 60, mr = 20, mt = 20, mb = 50;
  const pw = W - ml - mr, ph = H - mt - mb;

  // Clear
  ctx.fillStyle = "#0d1117";
  ctx.fillRect(0, 0, W, H);

  // Grid
  ctx.strokeStyle = "#30363d";
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 100; i += 20) {
    const x = ml + (i / 100) * pw;
    const y = mt + (1 - i / 100) * ph;
    ctx.beginPath(); ctx.moveTo(x, mt); ctx.lineTo(x, mt + ph); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ml, y); ctx.lineTo(ml + pw, y); ctx.stroke();
    ctx.fillStyle = "#8b949e";
    ctx.font = "11px -apple-system, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(i, x, mt + ph + 16);
    ctx.textAlign = "right";
    ctx.fillText(i, ml - 8, y + 4);
  }

  // Axis labels
  ctx.fillStyle = "#8b949e";
  ctx.font = "12px -apple-system, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Team Context & Winning (SHAP contribution) — Percentile", ml + pw / 2, H - 6);
  ctx.save();
  ctx.translate(14, mt + ph / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText("Individual Performance (SHAP contribution) — Percentile", 0, 0);
  ctx.restore();

  // Sort so MVPs draw on top
  pool.sort((a, b) => (a.was_mvp ? 1 : 0) - (b.was_mvp ? 1 : 0));

  // Max share for sizing
  const maxShare = Math.max(...pool.map(d => d.predicted_share), 0.01);

  scatterDots = [];
  pool.forEach(d => {
    const cx = ml + (d._wx / 100) * pw;
    const cy = mt + (1 - d._iy / 100) * ph;
    const r = Math.max(8, 8 + (d.predicted_share / maxShare) * 10);
    const img = d.headshot ? getHeadshot(d.headshot) : null;
    const borderColor = d.was_mvp ? "#f0b132" : "#388bfd";
    const borderWidth = d.was_mvp ? 2.5 : 1.5;

    ctx.save();
    // Clip to circle
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();

    if (img && img._loaded) {
      // Draw headshot cropped to circle
      const s = r * 2;
      ctx.drawImage(img, cx - r, cy - r, s, s);
    } else {
      // Fallback: colored circle with initials
      ctx.fillStyle = d.was_mvp ? "rgba(240, 177, 50, 0.85)" : "rgba(56, 139, 253, 0.5)";
      ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
      const parts = d.player.split(" ");
      const initials = parts.length >= 2 ? parts[0][0] + parts[parts.length - 1][0] : d.player[0];
      ctx.fillStyle = "#fff";
      ctx.font = `bold ${Math.round(r * 0.9)}px -apple-system, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(initials, cx, cy);
    }
    ctx.restore();

    // Border ring
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderWidth;
    ctx.stroke();

    scatterDots.push({ cx, cy, r, data: d });
  });

  // Legend
  ctx.fillStyle = "rgba(240, 177, 50, 0.85)";
  ctx.beginPath(); ctx.arc(ml + 10, mt + 16, 5, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = "#f0b132"; ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.arc(ml + 10, mt + 16, 5, 0, Math.PI * 2); ctx.stroke();
  ctx.fillStyle = "#e6edf3";
  ctx.font = "12px -apple-system, sans-serif";
  ctx.textAlign = "left";
  ctx.fillText("MVP Winner (gold border)", ml + 20, mt + 20);

  ctx.fillStyle = "rgba(56, 139, 253, 0.6)";
  ctx.beginPath(); ctx.arc(ml + 10, mt + 36, 5, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = "#388bfd"; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(ml + 10, mt + 36, 5, 0, Math.PI * 2); ctx.stroke();
  ctx.fillStyle = "#e6edf3";
  ctx.fillText("Non-winner (blue border)", ml + 20, mt + 40);

  // Count label
  ctx.fillStyle = "#8b949e";
  ctx.font = "11px -apple-system, sans-serif";
  ctx.textAlign = "right";
  ctx.fillText(`${pool.length} players`, W - mr, mt + 14);
}

init();
</script>
</body>
</html>
